#' Baseline DGP from a small dimensional DSGE model calibrated as in Herwartz, Ploedt 2014
#'
#' @param Tob Numeric, length of simulated time series
#' @param Break Numeric, time point of structural break (of variances)
#' @param Edist Character, distribution type of simulated structural shocks, Edist = c('tdist', 'chidist', 'normdist', 'unifdist', 'gammadist', 'betadist', 'mixed_a', "mixed_b").
#' @param v Numeric, degrees of freedom for distribution of simulated structural shocks
#' @param Par List, generated by function \code{\link{DSGE2VAR.DGP1}} collects VAR parameters of DSGE
#' @param Volaregim Vector, a (1x3) or (1x6) vector controlling variance regimes for the structural shocks
#' @param Combi Matrix, a (3x3) matrix, if provided, instruments are linear combination of the true underlying structural shocks
#' @param ME Vector, a (1x3) vector containing standard errors of normal white noise as measurement errors in the variables
#' @param VolaRand Vector, a (1x2) or (1x4) vector controlling the min and max of uniform distribution, from which variance regims are drawn
#' @param MERand Vector, a (1x2) vector containing the min and max of uniform distribution, from which the standard errors of normal white noise as measurement errors are drawn
#'
#' @return A list containing simulated macroeconomic variables, structural shocks and their instruments
#' @export DGP1
#'
#' @examples NULL
DGP1 <- function(Par, Tob, Break = NULL, Volaregim = NULL, VolaRand = NULL,
                 Edist = c('tdist', 'chidist', 'normdist', 'unifdist', 'gammadist', 'betadist', 'mixed_a', "mixed_b"),
                 v = 8, Combi = NULL, ME = NULL, MERand = NULL){

  # DGP Parameters
  A_1      <- Par$A_1
  A_2      <- Par$A_2
  B        <- Par$B

  Training <- 1000

  if (is.null(Break)) { # no volatility break

    if (!is.null(Volaregim)){
      V_1   <- diag(Volaregim)
    } else {
      V_1   <- diag(3)
    }

    # Initilization
    Y <- epsilon <- e_iv <- e_piv <- e_wiv <- matrix(0, 3, Tob + Training)
    Y[, 1]  <- c(1,1,1)
    Y[, 2]  <- c(1.2, 0.4, 0.9)

    # simulation of shocks
    for(i in 3:(Tob + Training)){
      if(Edist == 'tdist'){
        e_t     <- rt(3, v)*sqrt((v - 2)/v)
        e_t     <- V_1 %*% e_t %>% t()
      }else if(Edist == 'chidist'){
        e_t     <- (rchisq(3, v) - v)*sqrt(1/(2*v))
        e_t     <- V_1 %*% e_t %>% t()
      }else if(Edist == 'normdist'){
        e_t     <- rnorm(3)
        e_t     <- V_1 %*% e_t %>% t()
      }else if(Edist == 'unifdist'){
        e_t     <- runif(3, -2, 2)
        e_t     <- V_1 %*% e_t %>% t()
      }else if(Edist == 'gammadist'){
        e_t     <- (rgamma(3, shape = 0.5, scale = 1) - 0.5)*sqrt(2)
        e_t     <- V_1 %*% e_t %>% t()
      }else if(Edist == 'betadist'){
        e_t     <- (rbeta(3, 0.5, 0.5) - 0.5/(0.5 + 0.5))*sqrt(((0.5 + 0.5)^2*(0.5 + 0.5 +1))/(0.5*0.5))
        e_t     <- V_1 %*% e_t %>% t()
      }else if(Edist == 'mixed_a'){
        e_t     <- c(rnorm(1), rt(1, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
        e_t     <- V_1 %*% e_t %>% t()
      }else if(Edist == 'mixed_b'){
        e_t     <- c(rt(2, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
        e_t     <- V_1 %*% e_t %>% t()
      }

      # simulation of variable values and iv
      e_t     <- matrix(e_t, nrow = 3, ncol = 1) # "reshape" e_t

      Y[, i]         <- A_1 %*% Y[, (i-1)] + A_2 %*% Y[, (i-2)] + B %*% e_t
      epsilon[,i]    <- e_t
      noise          <- rnorm(3)
      e_iv[,i]       <- e_t + noise
      e_wiv[,i]      <- e_t / sqrt(Tob) + noise
      e_piv[,i]      <- Combi %*% e_t + noise

      # data contains measurement error
      if (!is.null(ME)) {
        Y[, i]       <- Y[, i] + diag(ME) %*% rnorm(3)
      }

      # data contains random measurement error
      if (!is.null(MERand)){
        me           <- runif(3, min = MERand[1], max = MERand[2])
        Y[, i]       <- Y[, i] + diag(me) %*% rnorm(3)
      }
    }
  } else {

    n <- length(Break) # number of volatility regimes
    if (n == 1) {
      # define volatility regime
      if (!is.null(Volaregim)){
        V_1   <- diag(Volaregim)
      } else if (!is.null(VolaRand)){
        volas <- runif(3, min = VolaRand[1], max = VolaRand[2])
        V_1   <- diag(volas)
      } else {stop("Variance regims undefined!")}

      # Initilization
      Y <- epsilon <- e_iv <- e_piv <- e_wiv <- matrix(0, 3, Tob + Training)
      Y[, 1]  <- c(1,1,1)
      Y[, 2]  <- c(1.2, 0.4, 0.9)

      # Phase before valatility change
      Phase1 <- Training + Break

      # simulation of shocks
      for(i in 3:(Tob + Training)){
        if(i < Phase1){
          if(Edist == 'tdist'){
            e_t     <- rt(3, v)*sqrt((v - 2)/v)
          }else if(Edist == 'chidist'){
            e_t     <- (rchisq(3, v) - v)*sqrt(1/(2*v))
          }else if(Edist == 'normdist'){
            e_t     <- rnorm(3)
          }else if(Edist == 'unifdist'){
            e_t     <- runif(3, -2, 2)
          }else if(Edist == 'gammadist'){
            e_t     <- (rgamma(3, shape = 0.5, scale = 1) - 0.5)*sqrt(2)
          }else if(Edist == 'betadist'){
            e_t     <- (rbeta(3, 0.5, 0.5) - 0.5/(0.5 + 0.5))*sqrt(((0.5 + 0.5)^2*(0.5 + 0.5 +1))/(0.5*0.5))
          }else if(Edist == 'mixed_a'){
            e_t     <- c(rnorm(1), rt(1, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
          }else if(Edist == 'mixed_b'){
            e_t     <- c(rt(2, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
          }
        } else {
          if(Edist == 'tdist'){
            e_t     <- rt(3, v)*sqrt((v - 2)/v)
            e_t     <- V_1 %*% e_t %>% t()
          }else if(Edist == 'chidist'){
            e_t     <- (rchisq(3, v) - v)*sqrt(1/(2*v))
            e_t     <- V_1 %*% e_t %>% t()
          }else if(Edist == 'normdist'){
            e_t     <- rnorm(3)
            e_t     <- V_1 %*% e_t %>% t()
          }else if(Edist == 'unifdist'){
            e_t     <- runif(3, -2, 2)
            e_t     <- V_1 %*% e_t %>% t()
          }else if(Edist == 'gammadist'){
            e_t     <- (rgamma(3, shape = 0.5, scale = 1) - 0.5)*sqrt(2)
            e_t     <- V_1 %*% e_t %>% t()
          }else if(Edist == 'betadist'){
            e_t     <- (rbeta(3, 0.5, 0.5) - 0.5/(0.5 + 0.5))*sqrt(((0.5 + 0.5)^2*(0.5 + 0.5 +1))/(0.5*0.5))
            e_t     <- V_1 %*% e_t %>% t()
          }else if(Edist == 'mixed_a'){
            e_t     <- c(rnorm(1), rt(1, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
            e_t     <- V_1 %*% e_t %>% t()
          }else if(Edist == 'mixed_b'){
            e_t     <- c(rt(2, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
            e_t     <- V_1 %*% e_t %>% t()
          }
        }

        # simulation of variable values and iv
        e_t     <- matrix(e_t, nrow = 3, ncol = 1) # "reshape" e_t

        Y[, i]         <- A_1 %*% Y[, (i-1)] + A_2 %*% Y[, (i-2)] + B %*% e_t
        epsilon[,i]    <- e_t

        if(i < Phase1){
          noise        <- rnorm(3)
        } else {
          noise        <- V_1 %*% rnorm(3)
        }
        e_iv[,i]       <- e_t + noise
        e_wiv[,i]      <- e_t / sqrt(Tob) + noise
        e_piv[,i]      <- Combi %*% e_t + noise


        # data contains measurement error
        if (!is.null(ME)) {
          Y[, i]       <- Y[, i] + diag(ME) %*% rnorm(3)
        }

        # data contains random measurement error
        if (!is.null(MERand)){
          me           <- runif(3, min = MERand[1], max = MERand[2])
          Y[, i]       <- Y[, i] + diag(me) %*% rnorm(3)
        }
      }
    } else if (n == 2) {
      # define volatility regimes
      if (!is.null(Volaregim)){
        V_1    <- diag(Volaregim[1:3])
        V_2    <- diag(Volaregim[4:6])
      } else if (!is.null(VolaRand)){
        volas1 <- runif(3, min = VolaRand[1], max = VolaRand[2])
        volas2 <- runif(3, min = VolaRand[3], max = VolaRand[4])
        V_1    <- diag(volas1)
        V_2    <- diag(volas2)
      } else {stop("Variance regims undefined!")}

      # Initilization
      Y <- epsilon <- e_iv <- e_piv <- e_wiv <- matrix(0, 3, Tob + Training)
      Y[, 1]  <- c(1,1,1)
      Y[, 2]  <- c(1.2, 0.4, 0.9)

      # Phase before valatility change
      Phase1 <- Training + Break[1]
      Phase2 <- Training + Break[2]

      # simulation of shocks
      for(i in 3:(Tob + Training)){
        if(i < Phase1){
          if(Edist == 'tdist'){
            e_t     <- rt(3, v)*sqrt((v - 2)/v)
          }else if(Edist == 'chidist'){
            e_t     <- (rchisq(3, v) - v)*sqrt(1/(2*v))
          }else if(Edist == 'normdist'){
            e_t     <- rnorm(3)
          }else if(Edist == 'unifdist'){
            e_t     <- runif(3, -2, 2)
          }else if(Edist == 'gammadist'){
            e_t     <- (rgamma(3, shape = 0.5, scale = 1) - 0.5)*sqrt(2)
          }else if(Edist == 'betadist'){
            e_t     <- (rbeta(3, 0.5, 0.5) - 0.5/(0.5 + 0.5))*sqrt(((0.5 + 0.5)^2*(0.5 + 0.5 +1))/(0.5*0.5))
          }else if(Edist == 'mixed_a'){
            e_t     <- c(rnorm(1), rt(1, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
          }else if(Edist == 'mixed_b'){
            e_t     <- c(rt(2, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
          }
        } else if(i < Phase2) {
          if(Edist == 'tdist'){
            e_t     <- rt(3, v)*sqrt((v - 2)/v)
            e_t     <- V_1 %*% e_t
          }else if(Edist == 'chidist'){
            e_t     <- (rchisq(3, v) - v)*sqrt(1/(2*v))
            e_t     <- V_1 %*% e_t
          }else if(Edist == 'normdist'){
            e_t     <- rnorm(3)
            e_t     <- V_1 %*% e_t
          }else if(Edist == 'unifdist'){
            e_t     <- runif(3, -2, 2)
            e_t     <- V_1 %*% e_t
          }else if(Edist == 'gammadist'){
            e_t     <- (rgamma(3, shape = 0.5, scale = 1) - 0.5)*sqrt(2)
            e_t     <- V_1 %*% e_t
          }else if(Edist == 'betadist'){
            e_t     <- (rbeta(3, 0.5, 0.5) - 0.5/(0.5 + 0.5))*sqrt(((0.5 + 0.5)^2*(0.5 + 0.5 +1))/(0.5*0.5))
            e_t     <- V_1 %*% e_t
          }else if(Edist == 'mixed_a'){
            e_t     <- c(rnorm(1), rt(1, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
            e_t     <- V_1 %*% e_t
          }else if(Edist == 'mixed_b'){
            e_t     <- c(rt(2, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
            e_t     <- V_1 %*% e_t
          }
        } else {
          if(Edist == 'tdist'){
            e_t     <- rt(3, v)*sqrt((v - 2)/v)
            e_t     <- V_2 %*% e_t
          }else if(Edist == 'chidist'){
            e_t     <- (rchisq(3, v) - v)*sqrt(1/(2*v))
            e_t     <- V_2 %*% e_t
          }else if(Edist == 'normdist'){
            e_t     <- rnorm(3)
            e_t     <- V_2 %*% e_t
          }else if(Edist == 'unifdist'){
            e_t     <- runif(3, -2, 2)
            e_t     <- V_2 %*% e_t
          }else if(Edist == 'gammadist'){
            e_t     <- (rgamma(3, shape = 0.5, scale = 1) - 0.5)*sqrt(2)
            e_t     <- V_2 %*% e_t
          }else if(Edist == 'betadist'){
            e_t     <- (rbeta(3, 0.5, 0.5) - 0.5/(0.5 + 0.5))*sqrt(((0.5 + 0.5)^2*(0.5 + 0.5 +1))/(0.5*0.5))
            e_t     <- V_2 %*% e_t
          }else if(Edist == 'mixed_a'){
            e_t     <- c(rnorm(1), rt(1, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
            e_t     <- V_2 %*% e_t
          }else if(Edist == 'mixed_b'){
            e_t     <- c(rt(2, v)*sqrt((v - 2)/v), (rchisq(1, v) - v)*sqrt(1/(2*v)))
            e_t     <- V_2 %*% e_t
          }
        }

        # simulation of variable values and iv
        e_t     <- matrix(e_t, nrow = 3, ncol = 1) # "reshape" e_t

        Y[, i]         <- A_1 %*% Y[, (i-1)] + A_2 %*% Y[, (i-2)] + B %*% e_t
        epsilon[,i]    <- e_t

        if(i < Phase1){
          noise        <- rnorm(3)
        } else if(i < Phase2) {
          noise        <- V_1 %*% rnorm(3)
        } else {
          noise        <- V_2 %*% rnorm(3)
        }
        e_iv[,i]       <- e_t + noise
        e_wiv[,i]      <- e_t / sqrt(Tob) + noise
        e_piv[,i]      <- Combi %*% e_t + noise

        # data contains measurement error
        if (!is.null(ME)) {
          Y[, i]       <- Y[, i] + diag(ME) %*% rnorm(3)
        }

        # data contains random measurement error
        if (!is.null(MERand)){
          me           <- runif(3, min = MERand[1], max = MERand[2])
          Y[, i]       <- Y[, i] + diag(me) %*% rnorm(3)
        }
      }
    } else {stop("Maximum number of volatility regimes is exceeded! ")}
  }



  # discard the traning data
  Y          <- Y[, -(1:Training)]        %>% t()
  epsilon    <- epsilon[, -(1:Training)]  %>% t()
  e_iv       <- e_iv[, -(1:Training)]     %>% t()
  e_piv      <- e_piv[, -(1:Training)]    %>% t()
  e_wiv      <- e_wiv[, -(1:Training)]    %>% t()

  # give them names
  colnames(Y)          <- c("x", "pi", "r")
  colnames(epsilon)    <- c("demand", "supply", "monetary")
  colnames(e_iv)       <- c("demand", "supply", "monetary")
  colnames(e_piv)      <- c("demand", "supply", "monetary")
  colnames(e_wiv)      <- c("demand", "supply", "monetary")

  # result
  erg                 <- list()
  erg[["Y"]]          <- Y
  erg[["shock"]]      <- epsilon
  erg[["iv"]]         <- e_iv
  erg[["piv"]]        <- e_piv
  erg[["wiv"]]        <- e_wiv


  return(erg)
}
