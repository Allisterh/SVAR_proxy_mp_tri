#' (parallelized version) Independence-based identification and evaluation based on Cramer-von Mises distance
#'
#' @param Data List containing simulated data
#' @param AOA List generated by function AOA.3d()
#' @param Iter Iter Integer. Maximum number of iterations for first stage optimization using DEoptim
#' @param Bmat Matrix of dimension (KxK), the true structural decomposition implied by the DGP
#' @param Steptol Numeric. Tolerance for steps without improvement for DEoptim
#' @param Stage2 Integer, if provided, second stage optimization will be performed at given iterations
#' @param mc.cores
#' @param Varname Character, names of variables in the systems
#'
#' @return A (KxKxh) array containing proportion of all simulated IRFs that lie in the AOA
#' @importFrom copula indepTestSim
#'@export simulate.cvm.mc
#'
#' @examples NULL
simulate.cvm.mc <- function(Data, AOA, Bmat, mc.cores, Iter = 1000, Steptol = 150, Stage2 = 50, Varname = c("x", "pi", "r")){

  Size     <- length(Data)
  K        <- ncol(Data[[1]]$Y)
  Tob      <- nrow(Data[[1]]$Y)
  p        <- 2
  cob      <- copula::indepTestSim(n = Tob - p, p = K, verbose = FALSE)
  Step     <- dim(AOA$L)[3] - 1
  eva.temp <- array(NA, c(K, K, Step + 1, Size))
  mse.temp <- matrix(NA, nrow = Size, ncol = 4)

  kernel.fct <- function(Data){
    var2 <- vars::VAR(Data$Y, p = 2, type = "none")
    Bmat.temp <- get.id.cvm(Model = var2, dd = cob, Iter = Iter, Steptol = Steptol, Stage2 = Stage2)$B
    eva.temp  <- eva.best(Model = var2, AOA = AOA, Step = Step, Bmat = Bmat.temp, Varname = Varname)
    mse.temp  <- eva.sign.UMP(Bhat = Bmat.temp, B = Bmat, Reorder = T)
    return(list("eva.temp" = eva.temp, "mse.temp" = mse.temp))
  }

  TEMP <- parallel::mclapply(Data, kernel.fct, mc.cores = mc.cores)

  eva.log <- matrix(NA, nrow = Size, ncol = K^2*(Step+1))
  for (i in 1:Size) {
    eva.log[i,] <- c(TEMP[[i]][["eva.temp"]])
    mse.temp[i,] <- TEMP[[i]][["mse.temp"]]
  }

  erg.aoa <- array(colMeans(eva.log), c(K, K, Step + 1))
  mse     <- colSums(mse.temp, na.rm = T)
  UMP     <- mse[1]/Size
  mse.mp  <- mse[-1]/mse[1]

  erg     <- list("aoa" = erg.aoa, "ump" = UMP, "mse.mp" = mse.mp)

  return(erg)
}
