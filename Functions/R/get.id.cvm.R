#' Independence-based identification based on Cramer-von Mises distance
#'
#' @param Model  A class of 'varest' or 'vec2var'
#' @param dd Object of class 'indepTestDist' (generated by 'indepTest' from package 'copula'). A simulated independent sample of the same size as the data.
#' @param Iter Integer. Maximum number of iterations for first stage optimization using DEoptim
#' @param Steptol Numeric. Tolerance for steps without improvement for DEoptim
#' @param Stage2 Integer, if provided, second stage optimization will be performed at given iterations
#' @param Grid.search
#'
#' @return list object of class "my.id"
#' @importFrom DEoptim DEoptim
#' @importFrom copula indepTest
#' @export get.id.cvm
#'
#' @examples NULL
get.id.cvm <- function(Model, dd, Iter, Steptol, Stage2 = NULL, Grid.search = NULL){
  p       <- Model$p
  K       <- Model$K
  u       <- resid(Model)
  Tob     <- Model$obs
  Varname <- names(Model$varresult)
  Beta    <- Model %>% vars::Bcoef() %>% t() # (Kp + mu) x K parameter matrix
  Z       <- Model$datamat[,-c(1:K)] %>% as.matrix() # (T-p) x (Kp + mu) covariates matrix
  Type    <- Model$type
  Covmat  <- crossprod(u) / (Tob - K*p - 1)

  B_chol  <- t(chol(Covmat))

  # lower and upper bounds for #1 stage optimization
  lower <- rep(0,  K*(K-1)/2)
  upper <- rep(pi, K*(K-1)/2)

  # a list of control parameters
  DE_control <- list(itermax = Iter, steptol = Steptol, trace = FALSE)

  DE_res <- suppressWarnings(DEoptim(fn = get.ICA.test, lower = lower, upper = upper,
                                     control = DE_control, testMethod = "cvm", B = B_chol,
                                     u = u, dd = dd))

  if (!is.null(Stage2)) {
    # #2 stage optimization
    theta_rot <- matrix(rnorm(n = K*(K-1)/2*Stage2, mean = DE_res$optim$bestmem, sd = 0.3), K*(K-1)/2, Stage2)
    theta_rot <- cbind(theta_rot, DE_res$optim$bestmem)
    # start vectors for iterative optimization approach
    startvec_list <- as.list(as.data.frame(theta_rot))

    erg_list <- lapply(X = startvec_list,
                       FUN = optim,
                       fn = get.ICA.test,
                       testMethod = "cvm",
                       gr = NULL,
                       B = B_chol,
                       u = u,
                       dd = dd,
                       method = ifelse(K == 2, "Brent", "Nelder-Mead"),
                       lower = ifelse(K == 2, -.Machine$double.xmax/2, -Inf),
                       upper = ifelse(K == 2, .Machine$double.xmax/2, Inf),
                       control = list(maxit = 1000),
                       hessian = FALSE)

    # print log-likelihood values from local maxima
    logliks <- sapply(erg_list, "[[", "value")

    if(min(logliks) < DE_res$optim$bestval){
      params <- sapply(erg_list, "[[", "par", simplify = FALSE)
      best.theta <- params[[which.min(logliks)]]
    }else{
      best.theta <- DE_res$optim$bestmem
    }
  } else {
      best.theta <- DE_res$optim$bestmem
  }

  Bmat          <- givens.Q.svars(best.theta, B_chol)
  rownames(Bmat) <- Varname

  erg <- list("B" = Bmat,
              "Varname" = Varname,
              "dat" = Model$y,
              "p" = p,
              "Tob" = Tob,
              "u" = u,
              "SigmaU" = Covmat,
              "Beta" = Beta,
              "Z" = Z,
              "type" = Type,
              "method" = "cvm")

  class(erg) <- "my.id"

  return(erg)
}
