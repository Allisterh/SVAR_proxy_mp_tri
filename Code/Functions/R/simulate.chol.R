#' Recursive identification and evaluation based on Cholesky decomposition
#'
#' @param Data List containing simulated data
#' @param AOA List generated by function AOA.3d()
#' @param Plot Logical, if Plot = TRUE, a plot of identification performance will be created
#' @param Subsample Vector, a (1x2) vector containing start- and end-point of subsamples that will be
#' subject to estimation and identification
#' @param Varname Character, names of variables in the systems
#'
#' @return A (KxKxh) array containing proportion of all simulated IRFs that lie in the AOA
#' @export simulate.chol
#'
#' @examples NULL
simulate.chol <- function(Data, AOA, Subsample = NULL, Plot = FALSE, Varname = c("x", "pi", "r")){

  Size     <- length(Data)
  K        <- ncol(Data[[1]]$Y)
  p        <- 2
  Step     <- dim(AOA$L)[3] - 1
  eva.temp <- array(NA, c(K, K, Step + 1, Size))

  start.time <- Sys.time()
  cat("\r", "...calculating finish time...")

  for (i in 1:Size) {
    # Data-generation
    Y.temp <- Data[[i]]

    # Subsample
    if (!is.null(Subsample)){
      Y.temp$Y     <- Y.temp$Y[Subsample[1]:Subsample[2],]
      Y.temp$shock <- Y.temp$shock[Subsample[1]:Subsample[2],]
      Y.temp$iv    <- Y.temp$iv[Subsample[1]:Subsample[2],]
    }

    # Estimation
    var2   <- vars::VAR(Y.temp$Y, p = 2, type = "none")
    Tob    <- var2$obs
    u      <- resid(var2)
    Covmat <- t(u) %*% u / (Tob -1)

    # Identification
    Bmat.temp      <- t(chol(Covmat))
    IRF.temp       <- get.my.irf(Model = var2, Step = Step, Bmat = Bmat.temp, Normalize = TRUE, Varname = Varname)
    eva.temp[,,,i] <- Evaluate.AOA(IRF.temp, AOA = AOA)

    # print progress
    progress(i, max = Size, start.time = start.time)
  }

  erg <- array(NA, c(K, K, Step + 1))
  for (h in 1:(Step + 1)) {
    for (i in 1:K) {
      for (j in 1:K) {
        erg[i,j,h] <- mean(eva.temp[i,j,h,])
      }
    }
  }

  row.names(erg) <- Varname

  if (Plot == TRUE){
    plot(plot.simu(erg))
  }

  return(erg)
}
