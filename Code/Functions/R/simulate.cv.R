#' Identification and evaluation based on heteroscedasticity (shift in variance)
#'
#' @param Data List containing simulated data
#' @param AOA List generated by function AOA.3d()
#' @param Plot Logical, if Plot = TRUE, a plot of identification performance will be created
#' @param Break Numeric, integer or a (2x1) vector indicates the time point(s) of structural break(s)
#' @param Guess Logical, if Guess = True, the econometrician will make a consistent guess about the time point of structural break
#' @param Subsample Vector, a (1x2) vector containing start- and end-point of subsamples that will be
#' subject to estimation and identification
#' @param Varname Character, names of variables in the systems
#' @param Reorder Logical, if Reorder = TRUE, columns of B matrix are reorded according to AOA
#' @param Bmat Matrix of dimension (KxK), the true structural decomposition implied by the DGP
#'
#' @return A (KxKxh) array containing proportion of all simulated IRFs that lie in the AOA
#' @export simulate.cv
#'
#' @examples NULL
simulate.cv <- function(Data, AOA, Reorder = TRUE, Subsample = NULL, Break, Guess = FALSE, Bmat,
                        Plot = FALSE, Varname = c("x", "pi", "r")){

  Size     <- length(Data)
  K        <- ncol(Data[[1]]$Y)
  p        <- 2
  Tob      <- nrow(Data[[1]]$Y)
  Step     <- dim(AOA$L)[3] - 1
  eva.temp <- array(NA, c(K, K, Step + 1, Size))
  mse.temp <- matrix(rep(NA, Size*4), nrow = Size, ncol = 4)

  start.time <- Sys.time()
  cat("\r", "...calculating finish time...")

  for (i in 1:Size) {
    # Data-generation
    Y.temp <- Data[[i]]

    # Subsample
    if (!is.null(Subsample)){
      Y.temp$Y     <- Y.temp$Y[Subsample[1]:Subsample[2],]
      Y.temp$shock <- Y.temp$shock[Subsample[1]:Subsample[2],]
      Y.temp$iv    <- Y.temp$iv[Subsample[1]:Subsample[2],]
    }

    # Estimation
    var2 <- vars::VAR(Y.temp$Y, p = 2, type = "none")

    # Guess the Break point
    if (Guess == TRUE){
      if (length(Break) == 1){
        alpha <- Break / Tob
        SB    <- (alpha + alpha * rnorm(1) / sqrt(Tob)) * Tob
      } else if (length(Break) == 2){
        alpha <- Break[2] / Tob
        SB    <- (alpha + alpha * rnorm(1) / sqrt(Tob)) * Tob
      } else {stop("Maximum number of structural breaks is exceeded! ")}
    } else {
      if (length(Break) == 1){
        SB    <- Break
      } else if (length(Break) == 2){
        SB    <- Break[2]
      } else {stop("Maximum number of structural breaks is exceeded! ")}
    }

    # Identification
    ID.temp        <- svars::id.cv(var2, SB)
    Bmat.temp      <- ID.temp$B
    if (Reorder){
      eva.temp[,,,i] <- eva.best(Model = var2, AOA = AOA, Step = Step, Bmat = Bmat.temp, Varname = Varname)
    } else {
      IRF.temp       <- get.my.irf(Model = var2, Step = Step, Bmat = Bmat.temp, Normalize = TRUE, Varname = Varname)
      eva.temp[,,,i] <- Evaluate.AOA(IRF.temp, AOA = AOA)
    }

    mse.temp[i,]     <- eva.sign.UMP(Bhat = Bmat.temp, B = Bmat, Reorder = T)

    # print progress
    progress(i, max = Size, start.time = start.time)
  }

  erg.aoa <- array(NA, c(K, K, Step + 1))
  for (h in 1:(Step + 1)) {
    for (i in 1:K) {
      for (j in 1:K) {
        erg.aoa[i,j,h] <- mean(eva.temp[i,j,h,])
      }
    }
  }

  row.names(erg.aoa) <- Varname

  if (Plot == TRUE){
    plot(plot.simu(erg.aoa))
  }

  mse     <- colSums(mse.temp, na.rm = T)
  UMP     <- mse[1]/Size
  mse.mp  <- mse[-1]/mse[1]

  erg     <- list("aoa" = erg.aoa, "ump" = UMP, "mse.mp" = mse.mp)
  return(erg)
}
