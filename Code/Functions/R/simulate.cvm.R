#' Independence-based identification and evaluation based on Cramer-von Mises distance
#'
#' @param Data List containing simulated data
#' @param AOA List generated by function AOA.3d()
#' @param Plot Logical, if Plot = TRUE, a plot of identification performance will be created
#' @param Subsample Vector, a (1x2) vector containing start- and end-point of subsamples that will be
#' subject to estimation and identification
#' @param Iter Iter Integer. Maximum number of iterations for first stage optimization using DEoptim
#' @param Bmat Matrix of dimension (KxK), the true structural decomposition implied by the DGP
#' @param Steptol Numeric. Tolerance for steps without improvement for DEoptim
#' @param Stage2 Integer, if provided, second stage optimization will be performed at given iterations
#' @param Varname Character, names of variables in the systems
#' @param Reorder Logical, if Reorder = TRUE, columns of B matrix are reorded according to AOA
#'
#' @return A (KxKxh) array containing proportion of all simulated IRFs that lie in the AOA
#' @importFrom copula indepTestSim
#'@export simulate.cvm
#'
#' @examples NULL
simulate.cvm <- function(Data, AOA, Reorder = TRUE, Subsample = NULL, Bmat, Iter = 1000, Steptol = 150, Stage2 = 50, Plot = FALSE, Varname = c("x", "pi", "r")){

  Size     <- length(Data)
  K        <- ncol(Data[[1]]$Y)
  Tob      <- nrow(Data[[1]]$Y)
  p        <- 2
  cob      <- copula::indepTestSim(n = Tob - p, p = K, verbose = FALSE)
  Step     <- dim(AOA$L)[3] - 1
  eva.temp <- array(NA, c(K, K, Step + 1, Size))
  mse.temp <- matrix(rep(NA, Size*4), nrow = Size, ncol = 4)

  start.time <- Sys.time()
  cat("\r", "...calculating finish time...")

  for (i in 1:Size) {
    # Data-generation
    Y.temp <- Data[[i]]

    # Subsample
    if (!is.null(Subsample)){
      Y.temp$Y     <- Y.temp$Y[Subsample[1]:Subsample[2],]
      Y.temp$shock <- Y.temp$shock[Subsample[1]:Subsample[2],]
      Y.temp$iv    <- Y.temp$iv[Subsample[1]:Subsample[2],]
    }

    # Estimation
    var2 <- vars::VAR(Y.temp$Y, p = 2, type = "none")

    # Identification
    ID.temp        <- get.id.cvm(Model = var2, dd = cob, Iter = Iter, Steptol = Steptol, Stage2 = Stage2)$B
    Bmat.temp      <- ID.temp
    if (Reorder){
      eva.temp[,,,i] <- eva.best(Model = var2, AOA = AOA, Step = Step, Bmat = Bmat.temp, Varname = Varname)
    } else {
      IRF.temp       <- get.my.irf(Model = var2, Step = Step, Bmat = Bmat.temp, Normalize = TRUE, Varname = Varname)
      eva.temp[,,,i] <- Evaluate.AOA(IRF.temp, AOA = AOA)
    }

    mse.temp[i,]     <- eva.sign.UMP(Bhat = Bmat.temp, B = Bmat, Reorder = T)

    # print progress
    progress(i, max = Size, start.time = start.time)
  }

  erg.aoa <- array(NA, c(K, K, Step + 1))
  for (h in 1:(Step + 1)) {
    for (i in 1:K) {
      for (j in 1:K) {
        erg.aoa[i,j,h] <- mean(eva.temp[i,j,h,])
      }
    }
  }

  row.names(erg.aoa) <- Varname

  if (Plot == TRUE){
    plot(plot.simu(erg.aoa))
  }

  mse     <- colSums(mse.temp, na.rm = T)
  UMP     <- mse[1]/Size
  mse.mp  <- mse[-1]/mse[1]

  erg     <- list("aoa" = erg.aoa, "ump" = UMP, "mse.mp" = mse.mp)
  return(erg)
}

